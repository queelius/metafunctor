<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>A Boolean Algebra Over Trapdoors | metafunctor</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="This project is available on GitHub.
Boolean Algebra
A Boolean algebra is a mathematical structure that captures the properties of logical operations and sets. Formally, it is defined as a 6-tuple $(B, \land, \lor, \neg, 0, 1)$, where

$B$ is a set of elements,
$\land$ ($\rm{and}$) and $\lor$ $\rm{or}$ are binary operations on $B$,
$\neg$ ($\rm{not}$) is a unary operation on $B$,
$0$ and $1$ are elements of $B$, often referred to as the minimum and maximum elements, respectively.

These components must satisfy certain axioms, including closure of $B$ under the operations, commutativity, associativity, distributivity, and the existence of identity and complement elements [1].">
    <meta name="generator" content="Hugo 0.139.3">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    
      <meta name="author" content = "admin">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]      
    }
  };
</script>
        
    
    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/trapdoor-boolean-model/">
    

    <meta property="og:url" content="http://localhost:1313/posts/trapdoor-boolean-model/">
  <meta property="og:site_name" content="metafunctor">
  <meta property="og:title" content="A Boolean Algebra Over Trapdoors">
  <meta property="og:description" content="This project is available on GitHub.
Boolean Algebra A Boolean algebra is a mathematical structure that captures the properties of logical operations and sets. Formally, it is defined as a 6-tuple $(B, \land, \lor, \neg, 0, 1)$, where
$B$ is a set of elements, $\land$ ($\rm{and}$) and $\lor$ $\rm{or}$ are binary operations on $B$, $\neg$ ($\rm{not}$) is a unary operation on $B$, $0$ and $1$ are elements of $B$, often referred to as the minimum and maximum elements, respectively. These components must satisfy certain axioms, including closure of $B$ under the operations, commutativity, associativity, distributivity, and the existence of identity and complement elements [1].">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-06-17T00:00:00+00:00">
    <meta property="og:image" content="http://localhost:1313/posts/trapdoor-boolean-model/featured.jpg">

  <meta itemprop="name" content="A Boolean Algebra Over Trapdoors">
  <meta itemprop="description" content="This project is available on GitHub.
Boolean Algebra A Boolean algebra is a mathematical structure that captures the properties of logical operations and sets. Formally, it is defined as a 6-tuple $(B, \land, \lor, \neg, 0, 1)$, where
$B$ is a set of elements, $\land$ ($\rm{and}$) and $\lor$ $\rm{or}$ are binary operations on $B$, $\neg$ ($\rm{not}$) is a unary operation on $B$, $0$ and $1$ are elements of $B$, often referred to as the minimum and maximum elements, respectively. These components must satisfy certain axioms, including closure of $B$ under the operations, commutativity, associativity, distributivity, and the existence of identity and complement elements [1].">
  <meta itemprop="datePublished" content="2023-06-17T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-06-17T00:00:00+00:00">
  <meta itemprop="wordCount" content="5583">
  <meta itemprop="image" content="http://localhost:1313/posts/trapdoor-boolean-model/featured.jpg">
  <meta itemprop="keywords" content="Rate-Distortion,Compression,Bernoulli,Bernoulli Model,Probabilistic Data Structure,Cryptography">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/posts/trapdoor-boolean-model/featured.jpg">
  <meta name="twitter:title" content="A Boolean Algebra Over Trapdoors">
  <meta name="twitter:description" content="This project is available on GitHub.
Boolean Algebra A Boolean algebra is a mathematical structure that captures the properties of logical operations and sets. Formally, it is defined as a 6-tuple $(B, \land, \lor, \neg, 0, 1)$, where
$B$ is a set of elements, $\land$ ($\rm{and}$) and $\lor$ $\rm{or}$ are binary operations on $B$, $\neg$ ($\rm{not}$) is a unary operation on $B$, $0$ and $1$ are elements of $B$, often referred to as the minimum and maximum elements, respectively. These components must satisfy certain axioms, including closure of $B$ under the operations, commutativity, associativity, distributivity, and the existence of identity and complement elements [1].">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  
  <header class="cover bg-top" style="background-image: url('/posts/trapdoor-boolean-model/featured.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        metafunctor
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/social/" title="Social page">
              Social
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About Me page">
              About Me
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/ghprojects/" title="GitHub Projects page">
              GitHub Projects
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="News page">
              News
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/probsets/" title="Problem Sets page">
              Problem Sets
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/projects/" title="Projects page">
              Projects
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/publications/" title="Publications page">
              Publications
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/research/" title="Research page">
              Research
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/search/" title="Search page">
              Search
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        
          <div class="f2 f1-l fw2 white-90 mb0 lh-title">A Boolean Algebra Over Trapdoors</div>
          
        
      </div>
    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        News
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">A Boolean Algebra Over Trapdoors</h1>
      
      <p class="tracked">
        By <strong>admin</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-06-17T00:00:00Z">June 17, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>This project is available on <a href="https://github.com/queelius/bernoulli_data_type/boolean-algebra-trapdor/">GitHub</a>.</p>
<h2 id="boolean-algebra">Boolean Algebra</h2>
<p>A Boolean algebra is a mathematical structure that captures the properties of logical operations and sets. Formally, it is defined as a 6-tuple $(B, \land, \lor, \neg, 0, 1)$, where</p>
<ul>
<li>$B$ is a set of elements,</li>
<li>$\land$ ($\rm{and}$) and $\lor$ $\rm{or}$ are binary operations on $B$,</li>
<li>$\neg$ ($\rm{not}$) is a unary operation on $B$,</li>
<li>$0$ and $1$ are elements of $B$, often referred to as the minimum and maximum elements, respectively.</li>
</ul>
<p>These components must satisfy certain axioms, including closure of $B$ under the operations, commutativity, associativity, distributivity, and the existence of identity and complement elements [1].</p>
<p>Boolean algebras have far-reaching application. They form the foundation of propositional logic and are fundamental to the design of digital circuits and computer architecture [2].</p>
<p>In set theory, a common representation of a Boolean algebra is the power set of a set $X$, denoted $\mathcal{P}(X)$, with the following correspondence:</p>
<ul>
<li>$B = \mathcal{P}(X)$,</li>
<li>$\land = \cap$ (set intersection),</li>
<li>$\lor = \cup$ (set union),</li>
<li>$\neg = \complement$ (set complement),</li>
<li>$0 = \emptyset$ (empty set),</li>
<li>$1 = X$ (universal set).</li>
</ul>
<p>This set-theoretic Boolean algebra, $(\mathcal{P}(X), \cap, \cup, \complement, \emptyset, X)$, is a canonical example of a Boolean algebra. It will be the starting point for our exploration of an Boolean algebra over trapdoors [3]. This structure will maintain the familiar properties of Boolean algebras while introducing cryptographic elements for secure computations and data structures.</p>
<h2 id="homomorphisms-in-boolean-algebra">Homomorphisms in Boolean Algebra</h2>
<p>A key concept in our exploration of trapdoor Boolean algebras is that of a homomorphism. In abstract algebra, a homomorphism is a structure-preserving map between two algebraic structures of the same type. In the context of Boolean algebras, a homomorphism is a function that preserves the operations and special elements of the Boolean algebra.</p>
<p>Given two Boolean algebras $(A, \land_A, \lor_A, \neg_A, 0_A, 1_A)$ and $(B, \land_B, \lor_B, \neg_B, 0_B, 1_B)$, a function $f: A \to B$ is a Boolean algebra homomorphism if for all $x, y \in A$:</p>
<ol>
<li>$f(x \land_A y) = f(x) \land_B f(y)$</li>
<li>$f(x \lor_A y) = f(x) \lor_B f(y)$</li>
<li>$f(\neg_A x) = \neg_B f(x)$</li>
<li>$f(0_A) = 0_B$</li>
<li>$f(1_A) = 1_B$</li>
</ol>
<p>In other words, a homomorphism preserves the structure of the Boolean algebra across the mapping. This preservation of structure is crucial as it allows us to perform operations in one Boolean algebra and have them correspond meaningfully to operations in another Boolean algebra [4].</p>
<p>Homomorphisms play a vital role in our construction of trapdoor Boolean algebras. They allow us to create a mapping between our original Boolean algebra and a new structure that incorporates cryptographic elements, while still maintaining the essential properties of a Boolean algebra. This preservation of structure ensures that operations performed in our trapdoor Boolean algebra still behave in ways that are logically consistent with standard Boolean operations.</p>
<p>In the following sections, we will introduce a specific homomorphism $F$ that maps elements from our original Boolean algebra to a Boolean algebra over bit strings, incorporating a cryptographic hash function. This homomorphism will be the foundation of our Boolean algebra over trapdoors, allowing us to perform Boolean operations in a way that leverages cryptographic properties.</p>
<h2 id="the-bernoulli-model">The Bernoulli Model</h2>
<p>Before we introduce our Bernoulli homomorphism, it&rsquo;s crucial to understand the underlying framework: the Bernoulli model.</p>
<p>The Bernoulli model is a probabilistic framework for representing and reasoning about approximations of values (where a value can be anything from a set, whether the set is something simple like $\{\rm{true}, \rm{false}\}$ or the set of functions of type $X \to Y$ (we call these Bernoulli maps in the general case).</p>
<p>It introduces a kind of controlled uncertainty into computations, allowing for trade-offs between accuracy and other desirable properties such as space efficiency or security.</p>
$$
B_{\mathcal{T}}.
$$$$
\Pr\bigl\\{B_{\mathcal{T}}(x) \neq x \bigr\\} = \epsilon(x).
$$<p>We may want to discuss the number of ways in which the Bernoulli Model can introduce errors. For a first-order Bernoulli model, $\epsilon(x) = \epsilon$ for all $x \in \mathcal{T}$, i.e., it is a constant (and usually known) probability. In this case, we say that the <em>order</em> of the Bernoulli model is $k=1$. For instance, if we had a noisy binary symmetric channel, we might have $\epsilon = 0.1$ for a given channel, and so whenever we observe a value from the channel, we know that there is a 10% chance the value is erroneous. For higher-order models, $\epsilon : \mathcal{T} \mapsto [0,1]$ represents error probabilities under different conditions.</p>
<p>Key properties of the Bernoulli Model include:</p>
<ol>
<li>
<p>Propagation of uncertainty: When operations are performed on Bernoulli approximations, the uncertainties combine in well-defined ways.</p>
</li>
<li>
<p>Trade-off between accuracy and other properties: By adjusting the probabilities, we can balance accuracy against other desirable characteristics of our system.</p>
</li>
<li>
<p>Generalization to complex types: The Bernoulli model can be applied to simple types like Boolean values, as well as to more complex types including functions and algebraic structures.</p>
</li>
</ol>
<p>In the context of our work on an approximate Boolean algebra over trapdoors, the Bernoulli Model provides a framework for analyzing and reasoning about the behavior of our cryptographic constructions.</p>
<h2 id="a-boolean-algebra-over-free-semigroups">A Boolean Algebra Over Free Semigroups</h2>
$$
    A := (\mathcal{P}\bigl(X^{\*}), \land = \cap, \lor = \cup, \neg = \complement, 0 = \emptyset, 1 = X^{\*}\bigr)
$$$$
    \\# : X^{\*} \times X^{\*} \mapsto X^{\*}.
$$$$
    X = \\{a,b\\}
$$$$
    X^{\*} = \\{\epsilon, a, b, aa, ab, ba, bb, aaa, aab, \ldots \\}
$$$$
    \mathcal{P}(X^\*) = \bigl\\{\emptyset, \\{\epsilon\\}, \\{a\\}, \\{b\\},
             \\{aa\\}, \ldots, \\{\epsilon,a\\}, \ldots,
             \\{a,a,babb\\}, \ldots \bigr\\},
$$<p>
where $\epsilon$ is the empty string.</p>
<p>Commonly, for Boolean alebras over finite sets, one approach is to represent sets with bit strings of length $n$ and map each set to a unique bit string, e.g., the mapping $\mathbb{A} \mapsto a_1 \ldots a_n$ where bit $a_j = 1$ if the $j$-th element (according to some ordering) is in $\mathbb{A}$ and otherwise $a_j = 0$. If we have $n$ bits, we can uniquely represent up to $2^n$ sets.</p>
<p>In our case, we have a Boolean albebra over the infinitely large free semigroup $X^{*}$. Our intention is to stick with the finite bit string representation, and say that the representation contains a type of controllable error on membership queries known as the the false positive rate (which is the probability that an element not in the set falsely tests positive for membership), assuming that elements are selected randomly from the free semigroup $X^{*}$.</p>
<p>Conceptually, we have an approximate Boolean algebra over the free semigroup $X^{*}$. We map element in $X^{*}$ to a bit string in $\{0,1\}^2$ using a cryptographic hash function $h : X^{*} \mapsto \{0,1\}^2$ such that if we randomly choose two elements in $X^{*}$, the probability that they map (hash) to the same value (collide) is $2^{-n}$. Collisions are the fundamental source of error in our model and what also qualifies the approximate Boolean algebra as a <a href="https://github.com/queelius/bernoulli_data_type">Bernoulli Model</a> process.</p>
<h2 id="approximate-boolean-algebra-over-trapdoors">Approximate Boolean Algebra Over Trapdoors</h2>
$$
    B := \bigl(\\{0,1\\}^n, \\&, |, \sim, 0^n, 1^n\bigr)
$$<p>
where $\&amp;$, $|$, and $\sim$ are defined on $\{0,1\}^n$ as the bitwise $\operatorname{and}$, $\operatorname{or}$, and $\operatorname{not}$ operations respectively. We have a homomorphism
$F$ defined as
\begin{align*}
F (\cap) &amp;= |,\\
F (\cup) &amp;= \&amp;\\
F (\complement) &amp;= \sim,\\
F (\emptyset) &amp;= 0^n,\\
F (X^{*}) &amp;= 1^n,\\
F (\{x_{j_1}, \ldots, x_{j_k}\}) &amp;= 0^n | h(x_{j_1}) | \cdots | h(x_{j_k}),
\end{align*}
where $h : X^{*} \mapsto \{0,1\}^n$ is a cryptographic hash function, $s \in X^{*}$ is a secret, and $\{x_{j_1}, \ldots, x_{j_k}\} \subseteq X^{*}$.</p>
<p>The operations in $A$ are set operations, while the operations in $B$ are bitwise operations. For example, suppose $x,y \in \mathcal{P}(X^{*})$ and $y \subset x$. If $F(x) = 0110$ and $F(y) = 0010$, then $F(x \land_A y) = F(x) \land_B F(y) = 0110 | 0010 = 00010 = F(y)$.</p>
<p>We assume $h$ uniformly distributes over $\{0,1\}^n$, which means that the apriori probability of a collision between two elements is $2^{-n}$. This is a fundamental property of cryptographic hash functions that we leverage in our construction.</p>
<p>If we map $A$ to $B$ using (approximate) homomorphism $F$ and then apply the same sequence of operations in both $A$ and $B$, we obtain some representation of the resultant set in $B$ for the ground truth in $A$. However, if we query $A$ and $B$ for membership of an element, we may find that there is a discrepancy between the results. We also find that the homomorphism $F$ itself is approximate in the negation operation, i.e., $F(\neg_A x) \neq \neg_B F(x)$.</p>
<p>These discrepenancies are a consequence of the finite number ($2^n$) of bit strings used to represent the elements $\mathcal{P}(X^{*})$ in the Boolean algebra $A$. As a result, we say that the Boolean algebra $B$ is an approximate Boolean algebra when used to computationally model operations in $A$. The approximation error is a controllable parameter that we can adjust by changing the number of bits ($n$) in the representations. Different types of queries or operations are associated with different error rates, so we can adjust $n$ to suit the specific requirements of our system.</p>
<p>The cryptographic hash function $h$ is a one-way function that allows us to map elements from $X^{*}$ to $\{0,1\}^n$ in a way that is computationally infeasible (even impossible, since the mapping is non-injective) to reverse. This property is crucial for the security of our construction, as it ensures that the original elements in $X^{*}$ cannot be easily reconstructed from their bit string representations. Since $F$ uses $h$ in its construction, it is an (approximate) one-way homomorphism $F$ that maps Boolean algebra $A$ a Boolean algebra $B$ over (one-way) trapdoors.</p>
<h3 id="homomorphism-properties">Homomorphism Properties</h3>
<p>We have two Boolean algebras, $A$ and $B$ as previously described. We seek to model the operations in $A$ in $B$ using the homomorphism $F$. In the proofs to follow, let $X = \{a,b\}$ and two particular sets in $\mathcal{P}(X^{*})$ be $x = \{a,b,ab\}$ and $y = \{b,ab,bb\}$.</p>
<p>To satisfy the properties of a homomorphism, the following properties must hold:</p>
<ol>
<li>$F(x \land_A y) = F(x) \land_B F(y)$</li>
<li>$F(x \lor_A y) = F(x) \lor_B F(y)$</li>
<li>$F(\neg_A x) = \neg_B F(x)$</li>
<li>$F(0_A) = 0_B$</li>
<li>$F(1_A) = 1_B$</li>
</ol>
<p>We show that these properties hold for all the properties except the third, which is not satisfied due to the approximate nature of the Boolean algebra over trapdoors. For this reason, we say that $F$ is an approximate Boolean algebra homomorphism. When we use the homomorphism $F$ to map elements from $A$ to $B$, we can perform operations in $A$ and have them correspond to operations in $B, albeit with some approximation error.</p>
<p><strong>Proof of First Property:</strong> We seek to prove the identity $F(x \land_A y) = F(x) \land_B F(y)$ for the sets $x$ and $y$ defined above using the homomorphism $F$. Starting from the LHS, we have
\begin{align*}
F(x \land_A y)
&amp;= F(x \cap y) \\
&amp;= F(\{b,ab\}) \\
&amp;= 0^n | h(b) | h(ab).
\end{align*}</p>
$$
F(x) \land_B F(y) = \bigl(h(a) | h(b) | h(ab)\bigr) \\& \bigl(h(b) | h(ab) | h(bb)\bigr).
$$$$
F(x) \land_A F(y) = h(b) | h(ab).
$$<p>
Thus, $F(x \land_A y) = F(x) \land_B F(y)$, which may be generalized to any two sets $x,y \in A$.
This completes the proof of the first property.</p>
<p><strong>Proof of Second Property:</strong> We seek to prove the identity $F(x \lor_A y) = F(x) \lor_B F(y)$ for the sets $x$ and $y$ defined above using the homomorphism $F$. Starting from the LHS, we have
\begin{align*}
F(x \lor_A y)
&amp;= F(x \cup y) \\
&amp;= F(\{a,b,ab,bb\}) \\
&amp;= 0^n | h(a) | h(b) | h(ab) | h(bb).
\end{align*}</p>
$$
F(x) \lor_B F(y) = \bigl(0^n | h(a) | h(b) | h(ab)\bigr) | \bigl(0^n | h(b) | h(ab) | h(bb)\bigr).
$$$$
F(x) \lor_B F(y) = 0^n | 0^n | h(a) | h(b) | h(b) | h(ab) | h(ab) | h(bb).
$$$$
F(x) \lor_B F(y) = 0^n | h(a) | h(b) | h(ab) | h(bb).
$$<p>
Thus, $F(x \lor_A y) = F(x) \lor_B F(y)$. This result generalizes to any two sets $x,y \in A$.
This completes the proof of the second property.</p>
<p><strong>Proof of Fourth Property:</strong> We seek to prove the identity $F(0_A) = 0_B$.
The proof is trivial, as the empty set $0_A = \emptyset$ maps to the all-zero bit string $0_B = 0^n$ by definition of the homomorphism $F$: $F(0_A) = F(\emptyset) = 0^n = 0_B$. This completes the proof of the fourth property.</p>
<p><strong>Proof of Fifth Property:</strong> We seek to prove the identity $F(1_A) = 1_B$.
The proof is also trivial, as the universal set $1_A = X^{*}$ maps to the all-one bit string $1_B = 1^n$ by definition of the homomorphism $F$:</p>
$$
F(\\{a,b,ab\\} \land_A \\{b,ab,bb\\}) = F^{-1}(F(\\{a,b,ab\\}) \land_B F(\\{b,ab,bb\\}),
$$<p>
since $F$ is one-way and has no inverse. Moreover, and related to this non-invertibility, we now show that the third property does not hold due to the properties of the cryptographic hash function $h$ used by the homomorphism $F$.</p>
<p><strong>Disproof of Third Property:</strong> We seek to disprove the identity $F(\neg_A x) = \neg_B F(x)$ for the set $x$ defined above using the homomorphism $F$. Starting from the LHS, we have
\begin{align*}
F(\neg_A x)
&amp;= F(x^\complement) \\
&amp;= F(X^{*} \setminus \{a,b,ab\}),
\end{align*}
which is an infinite set that includes all elements in $X^{*}$ except $a$, $b$, and $ab$. It includes elements like $bb$, $aaaaabbabababa$, $\epsilon$, and so on.</p>
$$
F(\neg_A x) = 0^n | h(bb) | h(aaaabbbabababa) | \cdots,
$$$$
F(\neg_A x) = 1^n.
$$$$
\neg_B F(x) = \sim \bigl(0^n | h(a) | h(b) | h(ab)\bigr).
$$$$
\neg_B F(x) \neq 1^n.
$$<p>
Thus, $F(\neg_A x) \neq \neg_B F(x)$, which demonstrates that the third property does not hold. As a result, we say that $F$ is an approximate Boolean algebra homomorphism. As $|x|$ (size of $x$) increases, the probability that $F(\neg_A x) = 0^n$ goes to $1$, which is also true for $F(\neg_A x)$. Asymptotically, as $|x| \to \infty$, the third property holds. This completes the disproof of the third property.</p>
<h2 id="single-level-hashing-scheme">Single-Level Hashing Scheme</h2>
<p>In the next section, <code>Two-Level Hashing Scheme</code>, we will introduce a two-level hashing scheme that reduces the space complexity of the single-level hashing scheme. In this section, we derive the space complexity of the single-level hashing scheme for representing free semigroups as &ldquo;dense&rdquo; bit strings of size $n$. We will find that, in order to keep the false positive rates on membership ($\in_B$) and subset ($\subseteq_B$) constant, the number of bits $n$ in the hash must grow exponentially with the number of elements in the set. This exponential growth limits the scalability of the scheme to very small sets. However, the two-level hashing scheme will address this limitation by reducing the space complexity for practical applications. We derive the space complexity of the single-level hashing scheme first because it is of theoretical interest and provides a foundation for the two-level hashing scheme.</p>
<h3 id="relational-predicates">Relational Predicates</h3>
<p>In this section, we view the Boolean algebra in a set-theoretic context. We then define some predicates that are fundamental to the algebra, namely membership and subset relations.</p>
<h4 id="set-membership">Set Membership</h4>
$$
    \in_A : X^{\*} \times 2^{X^{\*}} \mapsto \mathrm{bool}
$$$$
    a \in_A b := 1_b(a),
$$<p>
where $1_b$ is the set indicator function.</p>
$$
    \in_B : \\{0,1\\}^n \times \mathcal{P}(\\{0,1\\}^n) \mathrm{bool}
$$$$
    a \in_B b := a \land_B b = a.
$$<p>This just means we test for membership by testing that if $h(a)$
has a bit set (to 1), that bit must also be set in $h(b)$.
This permits false positives, i.e., $a \in_B b$ may test as true even if $a \notin_A b$.</p>
$$
    (F \emptyset) \lor_B (F \\{a\\}) = 0^n | h(a) = h(a).
$$$$
    (F X) \lor_B (F \\{a\\}) = 0^n | h(a) = 1^n.
$$$$
    (F \\{a\\}) \lor_B (F \\{b\\}) = h(a) | h(b).
$$<p>Let us denote the hash of $\{a\}$ as $Y$ and the hash of $\{b\}$ as $Z$. The probability that the $j$-th bit is set to $1$ in $Y$ is $1/2$ and the probability that the $j$-th bit is set to $1$ in $Z$ is also $1/2$. The probability that the $j$-th bit is set to $1$ in $X = Y \lor_B Z$ is the probability that the $j$-th bit is set to 1 in either $Y$ or $Z$:
\begin{align*}
\Pr\{ X_j = 1\}
&amp;= \Pr\{Y_j | Z_j = 1\}\
&amp;= \Pr\{(Y_j = 1) \lor (Z_j = 1)\}.
\end{align*}</p>
$$
\Pr\\{Y_j = 1 \lor Z_j = 1\\} = 1 - \Pr\\{Y_j = 0\\} \Pr\\{Z_j = 0\\},
$$$$
\Pr\\{Y_j = 1 \lor Z_j = 1\\} = 1 - 2^{-2}.
$$$$
    \Pr\\{X_j = 1\\} = 1 - 2^{-k}.
$$$$
\Pr\\{X_j = 1\\} \approx e^{-1/2^k}.
$$$$
    \Pr\\{X = 1^n\\} = \prod_{j=1}^{n} \Pr\\{X_j = 1\\} = \bigl(1 - 2^{-k}\bigr)^n \approx e^{-n/2^k}.
$$<p>Since $e^{-n/2^k} \to 1$ as $k \to \infty$, the union of $k$ singleton sets converges in probability to the universal set $1^n$. When we have the universal set, we have reached a stationary point in the union operation, and further unions will not change the result.</p>
<p>We use these results to compute the probability of a false positive in the membership and subset relations in the next section.</p>
<h5 id="false-negatives-and-false-positives">False Negatives and False Positives</h5>
<p>Suppose that we have a set $W$ and we want to ask if a randomly chosen element $x \in X$ is a member of $W$. Let us denote the hash of $x$ as $h$ and the $j$-th bit as $h_j$. If $x$ actually is a member of $W$, then all of the bits where $F x$ is set to to $1$ will, by construction, be set to $1$ in $F W$. The probability of a <strong>false negative</strong> is $0$.</p>
$$
    h_j = 1 \implies W_j = 1.
$$$$
    \lnot ( h_j = 1 \land W_j = 0 ).
$$<p>We are interested in computing the probability of this event:
\begin{align*}
\Pr\{\lnot ( h_j = 1 \land W_j = 0)\}
&amp;= 1 - \Pr\{h_j = 1 \land W_j = 0\} \\
&amp;= 1 - \Pr\{h_j = 1 \} \Pr\{W_j = 0\}.
\end{align*}</p>
$$
    \Pr\\{h_j = 1\\} = 1/2.
$$$$
\Pr\\{\lnot ( h_j = 1 \land W_j = 0)\\} = 1 - 2^{-(k+1)}.
$$<p>
where $k$ is the number of elements in $W$.</p>
<p>For $x$ to be a false positive, this implication must hold for all $n$ bit positions:
\begin{align*}
\varepsilon
&amp;= \Pr\{\text{$x \in W$ is a false positive}\}\\
&amp;= \prod_{j=1}^{n} \Pr\{\lnot ( h_j = 1 \land W_j = 0)\}\\
&amp;= \prod_{j=1}^{n} (1 - 2^{-(k+1)})\\
&amp;= (1 - 2^{-(k+1)})^n.
\end{align*}</p>
<h6 id="asymptotic-false-positive-rate">Asymptotic False Positive Rate</h6>
$$
\varepsilon_{\in} = (1 - 2^{-(k+1)})^n,
$$$$
\varepsilon_{\in} \approx e^{-n 2^{-(k+1)}},
$$$$
\varepsilon_{\in} = e^{\mathcal{O}(2^{-k})},
$$<p>
which indicates that $\varepsilon$ approaches 1 exponentially fast as $k$ increases.</p>
<h6 id="space-complexity">Space Complexity</h6>
$$
    n = \frac{\log \varepsilon}{\log(1 - 2^{-(k+1)})}.
$$$$
    n \approx \frac{\log \varepsilon}{2^{-(k+1)}}.
$$$$
    n = \mathcal{O}(2^k),
$$<p>
which means that to maintain a fixed error rate, the number of bits in the hash must grow exponentially with the number of elements in the set. This exponential growth limits the scalability of the scheme to very small sets.</p>
<p>We demonstrated that the probability of a false positive is a function of the number of elements $k$ in the set and the number of bits $n$ in the representation. Unsuprisingly, the probability of a false positive increases as the number of elements in the set $k$ increases and as the number of bits in the hash $n$ decreases, but now we have a probabilistic model that quantifies this relationship.</p>
<p><img src="/image/combined_fpr_vs_size.png" alt="False Positive Rate Analysis for Different Byte and Kilobyte Ranges"></p>
<blockquote>
<p>In Figure 1, the false positive rate decreases exponentially as the byte size of the hash increases for smaller sets of elements (k=4 to k=10). In Figure 2, we observe the false positive rate behavior over larger kilobyte sizes for larger sets (k=12 to k=16). The green dashed line represents the 5% false positive rate threshold. As k increases, achieving this threshold requires significantly more space, highlighting the trade-off between set size and hash size.</p>
</blockquote>
<h4 id="subset-relation">Subset Relation</h4>
$$
   \subseteq_A : 2^{X^{\*}} \mapsto 2^{X^{\*}} \mapsto \mathrm{bool}
$$$$
    a \subseteq_A b := \forall x \in a, x \in b.
$$$$
    \subseteq_B : \\{0,1\\}^n \times \\{0,1\\}^n \mapsto \\{0,1\\}
$$$$
   a \subseteq_B b := a | b = a,
$$<p>
which is identical to the set-indicator function. However, they have different error probabilities.</p>
$$
    W_j = 1 \implies X_j = 1,
$$$$
    \lnot ( W_j = 1 \land X_j = 0 ).
$$<p>
The probability of this event is given by
\begin{align*}
\Pr\{\lnot ( W_j = 1 \land X_j = 0)\}
&amp;= 1 - \Pr\{W_j = 1 \land X_j = 0\} \\
&amp;= 1 - \Pr\{W_j = 1 \} \Pr\{X_j = 0\} \\
&amp;= 1 - \Pr\{W_j = 1 \} \Pr\{X_j = 0\}.
\end{align*}
Recall that after $k$ union operations, the $j$-th bit in a set is $0$ with probability $2^{-k}$, therefore
\begin{align*}
\Pr\{\lnot ( W_j = 1 \land X_j = 0)\}
&amp;= 1 - \Pr\{W_j = 1 \} \Pr\{X_j = 0\} \\
&amp;= 1 - (1 - 2^{-k_1}) 2^{-k_2},
\end{align*}
where $k_1$ and $k_2$ are the number of elements in $W$ and $X$ respectively.</p>
<p>For $W \subseteq X$ to be a false positive, this implication must hold for all $n$ bit positions:
\begin{align*}
\varepsilon
&amp;= \Pr\{\text{$W \subseteq X$ is a false positive}\}\\
&amp;= \prod_{j=1}^{n} 1- (1 - 2^{-k_1}) 2^{-k_2}\\
&amp;= \bigl(1 - (1 - 2^{-k_1}) 2^{-k_2}\bigr)^n.
\end{align*}</p>
$$
\varepsilon_{\subseteq} \approx e^{-n (1 - 2^{-k_1}) 2^{-k_2}},
$$$$
\varepsilon_{\subseteq} \approx e^{-n e^{-(k_1 + k_2 \log 2)}}.
$$$$
\varepsilon_{\subseteq} = e^{\mathcal{O}(e^{-m})},
$$<p>
where $m = k_1 + k_2 \log 2$. This indicates that $\varepsilon_{\subseteq}$ approaches 1 exponentially fast as $m$ increases for a fixed $n$. This result is consistent with the earlier analysis of the false positive rate for the membership relation.</p>
<p>Since equality can be written as $A \subseteq B \land B \subseteq A$, the false positive rate for the equality relation is the product of the false positive rates for the subset relations in both directions.</p>
<h2 id="two-level-hashing-scheme">Two-Level Hashing Scheme</h2>
<p>In previous sections, we derived the space complexity of a single-level hashing scheme for
representing free semigroups as &ldquo;dense&rdquo; bit strings of size $n$. We found that, in order to keep the false positive rates on membership ($\in_B$) and subset ($\subseteq_B$) constant, the number of bits $n$ in the hash must grow exponentially with the number of elements in the set. This exponential growth limits the scalability of the scheme. To address this limitation, we introduce a two-level hashing scheme that reduces the space complexity for practical applications.</p>
<p>The two-level hashing scheme is a hierarchical structure that partitions the elements of the set into smaller subsets. For efficiency and compatability with existing hashing algorithms, when we hash an element, we do the following construction:</p>
<ol>
<li>We have a hash function that outputs $q$ bits.</li>
<li>The first $w$ bits of the hash are used to determine the subset (bin) to which the element belongs, $2^w$ subsets in total.</li>
<li>The remaining $q-w$ bits of the hash are used to represent the element within the subset.</li>
<li>We have $2^w$ bins and $q-w$ bits for each bin, resulting in a total of $n = 2^w(q-w)$ bits.</li>
</ol>
<p>This two-level hashing scheme allows us to reduce the number of bits in the hash for a given false positive rate $\varepsilon$. Let us derive the false positive rate for this construction, denoted as $\varepsilon(w,q)$.</p>
<h3 id="false-positive-rate">False Positive Rate</h3>
<h4 id="membership-relation">Membership Relation</h4>
<p>Assume $k$ elements are in the set already, and we seek to test membership of an element $x$ in it.
False negatives do not occur, as before, but a false positive occurs if the following condition holds:</p>
<ol>
<li>With probability $2^{-w}$, it maps to some particular subset.</li>
<li>In that subset, represented by $n-w$ bits, there are expected to be $k / 2^w$ elements.</li>
<li>We use the earlier derivation to find the probability of a false positive in the subset:</li>
</ol>
$$
\varepsilon(k,w,q) = (1 - 2^{-(k / 2^w + 1)})^{q-w}.
$$$$
\varepsilon(k) = e^{\mathcal{O}(2^{-k})},
$$<p>
which asymptotically is the same as the single-level hashing scheme. However, in practice, this is much more practical for reasonably large sets.</p>
<p>The space complexity of the two-level hashing scheme is given by $n = 2^w (q-w)$ bits for a false positive rate of $\varepsilon(k,w,q)$, or equivalently, $m = 2^w (q-w) / k$ bits per element for a false positive rate of $\varepsilon(k,w,q)$.</p>
<p>In Figure 3, we show the false positive rate for different values of $w$ and $q$.</p>
<h2 id="c-implementation-single-level-hashing-scheme">C++ Implementation: Single-Level Hashing Scheme</h2>
<p>We can implement a C++ class that models the Boolean algebra over trapdoors.
We generalize the concept of trapdoors to any type $X$, which we also parameterize
over the size of the hash $N$.</p>
$$
B_{\mathrm{X' \times X' \mapsto \mathrm{bool}}}(=(X',X'))
$$<p>
where $X&rsquo;$ is a trapdoor of type $X$ and the latent value is the equality
predicate.</p>
<p>We model it as a Boolean algebra over bit strings, where the operations are the bitwise
$\operatorname{and}$, $\operatorname{or}$, and $\operatorname{not}$ operations. We also
define the equality operator, which returns a Bernoulli Boolean that represents a Boolean
value indicating if the trapdoors are equal with a false positive rate of $2^{-8 N}$,
and</p>
<p>The <code>trapdoor_set&lt;X,N&gt;</code> class represents an approximate Boolean algebra over trapdoors (of type <code>X</code>), as we previously discussed. It is a specialization of <code>trapdoor&lt;X,N&gt;</code> that implements additional opoerations that can take place over the domain of <code>trapdoor&lt;X,N&gt;</code> and <code>trapdoor_set&lt;X,N&gt;</code>:</p>
<ol>
<li><code>empty_trapdoor_set&lt;X,N&gt;()</code> returns an empty set ($0_B$).</li>
<li><code>universal_trapdoor_set&lt;X,N&gt;()</code> returns a universal set ($1_B$).</li>
<li><code>operator+(trapdoor_set&lt;X,N&gt; const &amp; x, trapdoor_set&lt;X,N&gt; const &amp; y)</code> returns the union of two sets ($\lor_B$).</li>
<li><code>operator~(trapdoor_set&lt;X,N&gt; const &amp; x)</code> returns the complement of a set ($\neg_B$).</li>
<li><code>operator*(trapdoor_set&lt;X,N&gt; const &amp; x, trapdoor_set&lt;X,N&gt; const &amp; y)</code> returns the intersection of two sets ($\land_B$).</li>
<li><code>empty(trapdoor_set&lt;X,N&gt; const &amp; xs)</code> returns a Bernoulli Boolean that represents a Boolean value that is true if the set is empty with a false positive rate. Essentially, it is the probability that the hash of the set is zero, $0_B$, which occurs with a false positive rate $\varepsilon = 2^{-8 N}$.</li>
<li><code>in(trapdoor&lt;X,N&gt; const &amp; x, trapdoor_set&lt;X,N&gt; const &amp; xs)</code> returns a Bernoulli Boolean that represents a Boolean value that is true if the set contains the element with a false positive rate. See the section <code>Relational Predicates</code> in the <code>Single-Level Hashing Scheme</code> section for more details.</li>
</ol>
<p>The class <code>trapdoor_set</code> is a template class that takes a type <code>X</code> and a size <code>N</code> as template arguments. The class has a <code>value_hash</code> member that is an array of <code>char</code> of size <code>N</code>. The class has a default constructor that initializes the <code>value_hash</code> to zero. The class has a copy constructor that is defaulted. The class has two static member functions <code>empty_trapdoor_set</code> and <code>universal_trapdoor_set</code> that return an empty set and a universal set, respectively. The class has three overloaded operators <code>+</code>, <code>!</code>, and <code>*</code> that implement the union ($\lor_B$), complement ($\lnot_B$), and intersection ($\land_B$) operations, respectively.</p>
<p>For closure, the class has a <code>hash</code> member function that returns a hash of the set, which is just the hash already stored in it. This means we can compose these operations to form more complex operations, like creating a powerset of <code>trapdoor_set</code> objects.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">trapdoor</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> value_type <span style="color:#f92672">=</span> X;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The constructor initializes the value hash to the given value hash.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Since the hash is a cryptographic hash, the hash is one-way and so we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * cannot recover the original value from the hash.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * This also models the concept of an Oblivious Type, where the true value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * is latent and we permit some subset of operations on it. In this case,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the only operation we permit is the equality and hashing operations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param value_hash The value hash.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    trapdoor(std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, N<span style="color:#f92672">&gt;</span> value_hash) <span style="color:#f92672">:</span> value_hash(value_hash) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The default constructor initializes the value hash to zero. This value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * often denotes a special value of type X, but not necessarily.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    trapdoor() { value_hash.fill(<span style="color:#ae81ff">0</span>); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, N<span style="color:#f92672">&gt;</span> value_hash;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The hash function for the trapdoor class. It returns the value hash.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> hash(trapdoor <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x.value_hash;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Basic equality operator. It returns a Bernoulli Boolean that represents
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * a Boolean value indicating if the trapdoors are equal with a false positive rate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * of 2^{-8 N}. Different specializes of the trapdoor class may have different
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * false positive rates, but this is a reasonable default value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(trapdoor <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> lhs, trapdoor <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>{lhs.value_hash <span style="color:#f92672">==</span> rhs.value_hash, <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span><span style="color:#f92672">*</span>N};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The `or` operation in the Boolean algebra over bit strings.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> lor(trapdoor lhs, trapdoor <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        lhs.value_hash[i] <span style="color:#f92672">|=</span> rhs.value_hash[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lhs;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The `and` operation in the Boolean algebra over bit strings.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> land(trapdoor lhs, trapdoor <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        lhs.value_hash[i] <span style="color:#f92672">&amp;=</span> rhs.value_hash[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lhs;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The `not` operation in the Boolean algebra over bit strings.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> lnot(trapdoor x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        lhs.value_hash[i] <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>lhs.value_hash[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lhs;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> minimum() { <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>min(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> maximum() { <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>max(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The `minimum` operation in the Boolean algebra over trapdoors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> trapdoor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> minimum() { <span style="color:#66d9ef">return</span> trapdoor<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span>(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The `maximum` operation in the Boolean algebra over trapdoors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> trapdoor<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> maximum()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    trapdoor<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> x;
</span></span><span style="display:flex;"><span>    x.value_hash.fill(std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;::</span>min())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The trapdoor_set class models an approximate Boolean algebra over trapdoors.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * It is a specialization of the trapdoor class that implements additional operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * that can take place over the domain of trapdoor and trapdoor_set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">trapdoor_set</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> trapdoor<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    trapdoor_set(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> low_k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> high_k <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;::</span>infinity()),
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, N<span style="color:#f92672">&gt;</span> value_hash)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> trapdoor<span style="color:#f92672">&lt;</span>trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span>,N<span style="color:#f92672">&gt;</span>(value_hash),
</span></span><span style="display:flex;"><span>          low_k(low_k),
</span></span><span style="display:flex;"><span>          high_k(high_k) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    trapdoor_set() <span style="color:#f92672">:</span> trapdoor<span style="color:#f92672">&lt;</span>trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span>,N<span style="color:#f92672">&gt;</span>(), low_k(<span style="color:#ae81ff">0</span>), high_k(<span style="color:#ae81ff">0</span>) {}
</span></span><span style="display:flex;"><span>    trapdoor_set(trapdoor_set <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>    trapdoor_set <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(trapdoor_set <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> low_k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> high_k;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The size (cardinality) of the latent set (the set the trapdoor_set represents).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param xs The trapdoor_set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return The size range of the set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> size(trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> xs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_pair(xs.low_k, xs.high_k);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">The union operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> xs,
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> ys)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span>(lor(xs, ys).value_hash,
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>max(xs.low_k, ys.low_k), xs.high_k <span style="color:#f92672">+</span> ys.high_k);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> insert(trapdoor<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x, trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span> xs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        xs.value_hash[i] <span style="color:#f92672">|=</span> x.value_hash[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// since x could already be in xs, we do not increment the low_k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// only the high_k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    xs.high_k <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">~</span>(trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        x.value_hash[i] <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>x.value_hash[i];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assume |x| in [a, b]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// then |~x| has the following analysis.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//   - if |x| = a, then |~x| = |U| - a, where |U| is universal set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//   - if |x| = b, then |~x| = |U| - b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// so, |~x| in [|U|-b, |U|-a]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    x.low_k <span style="color:#f92672">=</span> maximum<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span>() <span style="color:#f92672">-</span> x.high_k;
</span></span><span style="display:flex;"><span>    x.high_k <span style="color:#f92672">=</span> maximum<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span>() <span style="color:#f92672">-</span> x.low_k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x,
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> trapdoor_set<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span>(x.value_hash <span style="color:#f92672">&amp;</span> y.value_hash,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// intersection could be empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>min(x.high_k, y.high_k) <span style="color:#75715e">// one could be a subset of the other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, size_t N<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> in(trapdoor<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x, trapdoor_set<span style="color:#f92672">&lt;</span>X,N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> xs
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((x.value_hash[i] <span style="color:#f92672">&amp;</span> xs.value_hash[i]) <span style="color:#f92672">!=</span> x.value_hash[i])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>{true, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// earlier, we showed that the fp rate is (1 - 2^{-k})^n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>{false, };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The subseteq_B predicate, x \subseteq_B y, is defined as x | y = x.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * It has an false positive rate of eps = (1 - 2^{-(k_1 + k_2 log 2)})^n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * which we approxiate as eps ~ e^{-n e^{-(k_1 + k_2 log 2)}}.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * we store the log(eps) instead: -n e^{-(k_1 + k_2 log 2)}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;=</span>(
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x,
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((x.value_hash[i] <span style="color:#f92672">&amp;</span> y.value_hash[i]) <span style="color:#f92672">!=</span> x.value_hash[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(false, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// false negative rate is 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// earlier, we showed that the fp rate is (1 - 2^{-(k_1 + k_2 log 2)})^n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>{true, };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x
</span></span><span style="display:flex;"><span>    trapdoor_set<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x.value_hash[i] <span style="color:#f92672">!=</span> y.value_hash[i])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> bernoulli<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>{false, <span style="color:#ae81ff">0.5</span>};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="appendix">Appendix</h2>
<h3 id="marginal-uniformity">Marginal Uniformity</h3>
$$
\Pr{}_D\\{a\\}
$$$$
\Pr\\{h(a)\\} \approx \Pr\\{h(b)\\}
$$<p>
even if $\Pr{}_D\{a\}$ and $\Pr{}_D\{b\}$ are significantly different.</p>
<p>When we do a membership query, we uniformly sample one of these representations so that the unigram distribution of elements in $\{0,1\}$ is uniform. This is a kind of <em>marginal uniformity</em> that is a property of the transformation $F$.</p>
<p>However, this approach has serious shortcomings:</p>
<ol>
<li>
<p>Only the marginal distribution of unigrams are uniformly distributed. Correlations in the joint distributions of the free semigroup $X^{*}$, such as bigrams, are not accounted for. We can apply this transformation to larger sequences, but the space complexity grows exponentially with the length of the sequence for a fixed false positive rate. In practice, for large $X$, even the unigram model may need to be approximated due to space limitations.</p>
</li>
<li>
<p>When we apply the Boolean operations on an <em>untrusted system</em>, it cannot be given the information about the distribution of the elements in $X$. This means that Boolean operations like $\land$ and $\lor$ cannot be performed on the untrusted system, only relational querieslike $\in$ and $\subseteq$.</p>
</li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "metafunctor-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  metafunctor 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
